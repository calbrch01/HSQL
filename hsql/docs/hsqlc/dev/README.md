# Dev Notes


## Table of Contents

- [Dev Notes](#dev-notes)
  - [Table of Contents](#table-of-contents)
  - [Terminology](#terminology)
  - [Generated files](#generated-files)
  - [Methodology - Translating from HSQL to ECL](#methodology---translating-from-hsql-to-ecl)
    - [Parsing](#parsing)
    - [Visiting](#visiting)
    - [Module wrapping and exports](#module-wrapping-and-exports)
    - [Behind The Scenes](#behind-the-scenes)
  - [JSDoc](#jsdoc)
  - [Unit testing](#unit-testing)

## Terminology

Compiling and transpiling are pretty wide terms, and here, we use the term compiling, or translation for ease of understanding. This is because `hsqlc` tends to perform a lot of things other than a straight sentence-by-sentence translation behind the scenes.

## Generated files

Modules under `gen` are autogenerated by antlr. They provide the lexing, parsing, and a base visitor for the rest of the program.
To regenerate all these files, java must be installed, and a version of antlr4 must be placed in the folder.
The `regen` script under npm will run the appropriate commands as necessary.

## Methodology - Translating from HSQL to ECL

The core of the conversion is through `antlr` and `string-template`.

The translation of HSQL to ECL happens in two phases - Parsing and Visiting.

The visitors are arranged into the `visitors` folder.

### Parsing

The parsing is a `antlr4` based parser (which creates LL(*) parsers), which uses the grammar `hsql.g4`.

The lexer and parser rules, are contained in one file, as makes it easier to manage.
The generated files, are stored in `gen/`. This includes the lexer, parser, and a base visitor. 

Most errors in parsing are unrecoverable, and yield appropriate messages which are caught and reported by `hsqlc`.

Successful parsing here generates two artifacts:
1. A Parse Tree - A parse tree representing the HSQL program
2. Two import flags, one for ML_Core (triggered by train and predict statements) and one for Visualizer (from plot statements)

### Visiting

`visitors/index.js` contains the main visitor class. This calls all the other visitor modules as required (Other visitor modules are present in the same directory), while travering the generated the parse tree. This design decision is to aid in modularity and aid in quick changes in future versions.

However, import statements, are directly processed by the main visitor. This is because most HSQL programs are expected to have import statements, and not requiring another visitor should improve performance, and most importantly, helps simplify code somewhat.

Information is returned by each of the visitors, by using objects of `VisitorExchangeObject`.

Visitors, perform further validation  of code, included but not limited to:
1. Variable checks
2. Aggregate (in select statements) and Method (in train statements) checks
3. Module wrapping

Visitors here are able to raise warnings, or raise errors, as required, and return.
Most warnings are recoverable, although errors may be unrecoverable or recoverable (Although in practise, most are unrecoverable and stops the visiting process).

Visiting yields many artifacts(represented as a `translationResults` object):
1. Errors/Warnings - a set of errors and their positions and tokens
2. Translated - an array of statements (join with ';' as required)
3. The Identifier Store - an object representing the types of all the various variables used.

### Module wrapping and exports

An important part of transpiling, is to have a general framework for the target program.
ECL has three definition visibility rules:
1. Default: These definitions are only accessible until the **next** export or shared definition.
2. Shared: Visible within the module
3. Export: Visible outside the module

HSQL does away with this confusion by using only the last two. Definitions can be marked as export, by an optional `export` statement. 

### Behind The Scenes

#### Export visiting

The export statement, is actually visited first, to gather information on what to export.
After the standard line translations, a simple check is done to make sure all the variables have been exported, otherwise it would indicate incorrect/duplicate entries have been presented to be exported.

#### Standard line translation

HSQL statements (other than inline ecl and map type statements) are of two types - Action statements, and definition statements.

Definition statements have the typical `x = something` structure. These are all allowed to be exported, and when being translated, a rough check is made to determine if it needs to be exported, and then the correct visibility is defined in the resulting ecl statement.

Action statements, are simple statements that don't have assignments, and have some purpose, eg. output statements.
To ensure all modules can execute when they have an action in them, they are actually assigned to reserved variable names in ecl, and a separate list of action statements are maintained for later use.


#### Module Wrapping

After all this, a simple line gets added

```ecl
export main := function return sequential(o1,o2,o3,...) end;
```

`o1,o2,o3,...` here, refer to all the reserved action variables created, in the order as per the HSQL program.
This is because ECL, actually prepares a graph of everything it needs to make the actions have effect.
Eg. `OUTPUT(a);` would imply that a, needs to be found out, to give an output.

Until this point in the program, there has been no mention of the module, but finally, the resultant statements get wrapped in the module starting and ending lines.
(It is important to note that this starting line is fused with the first action/definition, to prevent adding a ';')


## JSDoc

The project has been heavily marked with JSDoc comments. This provides two advantages, it documents the code, and IDEs like VSCode can use the metadata to help with providing autocompletions and type completions.

However, `antlr4` as of current, has provided an issue that the generated parsers have contexts which cannot be easily understood by JSDoc, and hence, some IDEs may fail at providing any autocomplete for such parser contexts.
In the project, they have been marked by either type `*` or `ParserRuleContext`. Labelling them with `ParserRuleContext` provides some basic autocomplete, which may be useful.

## Unit testing

Unit testing requires `mocha` and `chai` as a testing framework and `xml2js` to obtain the results from the ecl client tools.
Files under `tests/testScripts` are translated, and submitted to a hpcc cluster for testing via ecl program. This implies that ECL Client tools are required to be installed on the system.
Note that all the bundles are required to be installed to be able to run the unit tests, and logical files must be available as mentioned in [data-file](data-files/README.md)


